## 调用API必须遵循以下规则：

| 规则  | 方式  |
| ------------ | ------------ |
|  传输方式 |  为保证交易安全性，采用HTTPS传输 |
|  提交方式 |  采用get方法请求 |
|  数据格式 |  url参数  |
|  字符编码 |  统一采用UTF-8字符编码 |
| 签名算法  |  详细请看[签名](http://doc.shuabeiapp.com/index.php?s=/1&page_id=4)|
| Content-Type | application/json |


### 接口同步逻辑 ###
为了保证接口不止能够同步新的数据，也能同步数据的改动，这个项目几乎所有的接口都以`更新时间`为同步的主要依据。

**下面是保证接口同步完整的核心逻辑**

有可能出现同一毫秒中更改数据不止一条的情况，而且如果这些数据正好在请求的边界，就会导致请求混乱的请求。

假设1：
现在有1000条数据，按照更新时间排序之后，第90条到110条数据是同一时间更新的数据，我现在请求100条数据。

在正常情况下，返回的100条数据中会包含90-100条的数据，但是当下一次请求的时候，就会出现90-110条数据中，不能确定哪些数据已经同步过了，哪些数据没有同步。

为了解决这种问题，在接口的处理中，会一次向数据库请求101条（请求数量加一），并且检查第101条数据的更新时间与第100条的时间是否相同，如果不相同，就说明不存在前面的边界值问题，直接返回；如果相同就检查第99条与第101条的时间是否相同，如果不相同就返回99条，如果相同就返回检查第98条数据，以此类推，直到找到与第101条数据的更新时间不相同的数据为止；也就是说**返回的数据可能少于请求的数据。**


假设2：
现在有1000条数据，按照更新时间排序之后，第90条到210条数据是同一时间更新的数据，我现在请求100条数据。

按照假设一的处理方式，第一个请求返回0-89条数据，第二次请求的时候就会出现90-190条时间相同的情况，这里会出现返回数据为空的情况，从而导致用户误以为请求已经结束。

为了解决这个问题，我们会在第二次请求的时候一次性返回所有更新时间为第90条时间的所有数据。也就是返回的数据量可能会大于请求的数据。


### 接口同步位置的判断依据 ###
接口中通过上次更新时间（sync_time）来表示同步的位置。

当第一次请求的时候，sync_time设置为0，第一次请求的返回数据中会包含一个sync_time字段，第二次请求的时候需要带上这个sync_time，第二次请求也会返回一个新的sync_time，也就是这个sync_time 的值是由接口决定的，用户只需要保存，并且在下次请求的时候带上就行了。

### 接口同步结束的条件 ###
当接口返回的数据为空的时候，表示当前接口返回数据已经同步完成。这里需要注意的是，接口同步完成的时候也会返回sync_time, 这时需要保存起来，以便下一次同步时候使用。


### 接口同步的顺序 ###
因为一个接口的数据可能依赖别的接口的数据，所以必须先同步依赖数据的接口。

1. 同步基础数据接口；
2. 同步依赖数据接口；
3. 同步当前接口；

注意：这里可能会出现A依赖B，C的数据，逻辑上应该按照B、C、A的顺序同步。但是可能在同步C之后，B、A又添加了新的数据,这就导致同步A的时候还是会出现依赖的B数据没有被同步的情况。从而导致潜在的逻辑错误问题。

为了解决这个问题，需要从服务器端和用户端来解决。

服务器端口会判断如果请求的接口数据A，需要依赖其它数据，接口就会把最近更新的10分钟数据不返回。

比如，当前时间是'2016-10-09 14:50:20'，理论上应该同步到这个时间的数据，但是为了保证数据逻辑上完整，2016-10-09 14:40:20到2016-10-09 14:50:20更新的数据是不会返回的，这一步对用户的影响就是同步的数据会推迟十分钟才能同步到用户的系统中。但是考虑到用户同步间隔的时间，以及烈熊数据编辑的时间，十分钟是不会影响到用户数据使用的。

在用户端，用户调用接口的时候推荐在请求B、C之后，请求A之前，再次同步B、C接口（因为这个时刻可能改动的数据很少，所以会很快结束）然后在同步A的数据。